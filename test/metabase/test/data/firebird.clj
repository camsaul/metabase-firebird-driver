(ns metabase.test.data.firebird
  "Code for creating / destroying a FirebirdSQL database from a `DatabaseDefinition`."
  (:require [clojure.string :as str]
            [clojure.java.jdbc :as jdbc]
            [metabase.driver.sql-jdbc.connection :as sql-jdbc.conn]
            [metabase.test.data
             [interface :as tx]
             [sql :as sql.tx]
             [sql-jdbc :as sql-jdbc.tx]]
            [metabase.test.data.sql-jdbc
             [load-data :as load-data]
             [execute :as execute]]
            [metabase.util :as u]))

(sql-jdbc.tx/add-test-extensions! :firebird)

(defmethod tx/dbdef->connection-details :firebird [_ context {:keys [database-name]}]
   {:host     (tx/db-test-env-var-or-throw :firebird :host "localhost")
    :port     (tx/db-test-env-var-or-throw :firebird :port 3050)
    :user     (tx/db-test-env-var-or-throw :firebird :user "SYSDBA")
    :password (tx/db-test-env-var-or-throw :firebird :password "masterkey")
    :db       (tx/db-test-env-var-or-throw :firebird :db "metabase-testing")
    :additional-options (tx/db-test-env-var-or-throw :firebird :additional-options "charSet=UTF-8")})

(defmethod sql.tx/field-base-type->sql-type [:firebird :type/BigInteger] [_ _] "BIGINT")
;; Boolean was added in firebird 3, maybe use smallint for firebird 2 compatibility?
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Boolean]    [_ _] "BOOLEAN")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Date]       [_ _] "DATE")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/DateTime]   [_ _] "TIMESTAMP")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Decimal]    [_ _] "DECIMAL")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Float]      [_ _] "FLOAT")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Integer]    [_ _] "INTEGER")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Text]       [_ _] "VARCHAR(255)")
(defmethod sql.tx/field-base-type->sql-type [:firebird :type/Time]       [_ _] "TIME")

(defmethod sql.tx/pk-sql-type :firebird [_] "INTEGER GENERATED BY DEFAULT AS IDENTITY")

(defmethod sql.tx/pk-field-name :firebird [_] "id")

;; Use RECREATE TABLE to drop a table if it exists, in case some tables have not been dropped before
;; running tests
(defmethod sql.tx/create-table-sql :firebird
  [driver {:keys [database-name], :as dbdef} {:keys [table-name field-definitions table-comment]}]
  (let [pk-field-name (sql.tx/pk-field-name driver)]
    (format "RECREATE TABLE %s (\"%s\" %s PRIMARY KEY, %s)"
            (sql.tx/qualify+quote-name driver database-name table-name)
            pk-field-name
            (sql.tx/pk-sql-type driver)
            (->> field-definitions
                 (map (fn [{:keys [field-name base-type field-comment]}]
                        (format "\"%s\" %s"
                                field-name
                                (if (map? base-type)
                                  (:native base-type)
                                  (sql.tx/field-base-type->sql-type driver base-type)))))
                 (interpose ", ")
                 (apply str)))))

(defmethod sql.tx/drop-table-if-exists-sql :firebird [& _] nil)

(defmethod load-data/load-data! :firebird [& args]
  (apply load-data/load-data-one-at-a-time! args))

(defmethod execute/execute-sql! :firebird [& args]
  (apply execute/sequentially-execute-sql! args))

;; Firebird cannot create or drop databases on runtime
(defmethod sql.tx/create-db-sql :firebird [& _] nil)
(defmethod sql.tx/drop-db-if-exists-sql :firebird [& _] nil)

(defmethod sql.tx/qualified-name-components :firebird
  ([_ db-name]                       [db-name])
  ([_ db-name table-name]            [(tx/db-qualified-table-name db-name table-name)])
  ([_ db-name table-name field-name] [(tx/db-qualified-table-name db-name table-name) field-name]))

;; Drop all tables that are not system tables before running test
(defmethod tx/before-run :firebird [_]
  (let [connection-spec (sql-jdbc.conn/connection-details->spec :firebird
                          (tx/dbdef->connection-details :firebird :server nil))
        foreign-keys (jdbc/query
                       connection-spec
                       (str "select r.rdb$relation_name, r.rdb$constraint_name from rdb$relation_constraints r where (r.rdb$constraint_type='FOREIGN KEY')"))
        leftover-tables (map :rdb$relation_name (jdbc/query
                                                  connection-spec
                                                  (str "SELECT RDB$RELATION_NAME "
                                                       "FROM RDB$RELATIONS "
                                                       "WHERE RDB$VIEW_BLR IS NULL "
                                                       "AND (RDB$SYSTEM_FLAG IS NULL OR RDB$SYSTEM_FLAG = 0);")))]
    ;; First, kill all connections and statements that are still running
    (println "Killing all open connections to test db... ")
    (jdbc/execute! connection-spec ["DELETE FROM MON$ATTACHMENTS WHERE MON$ATTACHMENT_ID <> CURRENT_CONNECTION"])
    (println "[ok]")
    (println "Killing all running statements in test db... ")
    (jdbc/execute! connection-spec ["DELETE FROM MON$STATEMENTS WHERE MON$ATTACHMENT_ID <> CURRENT_CONNECTION"])
    (println "[ok]")
    ;; Second, remove all foreign keys, so tables can be properly dropped
    (doseq [constraint foreign-keys]
      (u/ignore-exceptions
        (printf "Dropping constraint \"%s\" on table \"%s\"...\n"
                                              (:rdb$constraint_name constraint)
                                              (:rdb$relation_name constraint))
        (jdbc/execute! connection-spec [(format "ALTER TABLE \"%s\" DROP CONSTRAINT \"%s\";"
                                              (:rdb$relation_name constraint)
                                              (:rdb$constraint_name constraint))])
        (println "[ok]")))
    ;; Third, drop all leftover tables
    (doseq [table leftover-tables]
      (u/ignore-exceptions
        (printf "Dropping leftover Firebird table \"%s\"...\n" (str/trimr table))
        (jdbc/execute! connection-spec [(format "DROP TABLE \"%s\";" (str/trimr table))])
        (println "[ok]")))
    (println "Destroyed all leftover tables.")))
